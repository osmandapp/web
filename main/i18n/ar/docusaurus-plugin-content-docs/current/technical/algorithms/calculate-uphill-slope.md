---
source-hash: 6f725a1fadd0a2c5cd2626f8424f87e2e54b060d0b683fd33a90f9426413a826
sidebar_position: 5
---

# حساب الصعود / النزول / الميل {#calculation-of-uphill--downhill--slope}

يستخدم OsmAnd خوارزميات مختلفة لحساب **الميل** و**الصعود** بناءً على بيانات الأقمار الصناعية SRTM المضمنة في الخرائط غير المتصلة بالإنترنت وبناءً على مسارات GPX المسجلة.

الهدف الرئيسي من حساب **الصعود** هو توفير معلومات ذات صلة حول مقدار **الطاقة الإضافية** التي تُبذل في الصعود، ومن الواضح أن ذلك يعتمد على عوامل متعددة مثل نوع المركبة أو طريقة النقل، والسطح، ووزن الشخص، وغيرها.
لذا في النهاية، يجب أن يكون **الصعود** معلمة تؤخذ في الاعتبار عند التوجيه بناءً على الارتفاع، لإنتاج توجيه فعال من حيث الطاقة.

الهدف الرئيسي من حساب **الميل** هو توفير مؤشر بصري للطرق شديدة الانحدار التي يجب تجنبها.

## الصعود / النزول {#uphill--downhill}

هناك العديد من المشكلات في حساب **الصعود** لأنه لا يوجد معيار، ولأنه يعتمد على طريقة النقل والعديد من المعلمات الأخرى، فمن الصعب توفير تحكم معقول للمستخدم حتى لا يكون معقدًا للغاية. عادةً ما يُقارن الصعود ببرامج أخرى، ولكن لا يوجد برنامج لديه معيار ذهبي.

يستخدم OsmAnd خوارزمية من 3 خطوات:

- تصفية البيانات المشوشة.
- إيجاد النقاط القصوى المحلية (الحد الأدنى والحد الأقصى).
- حساب مجموع الفروق بين الحد الأدنى والحد الأقصى.

تحتوي بعض المسارات على الكثير من البيانات المشوشة التي تحتاج إلى تصفية أولاً. في الوقت الحالي، نطبق التصفية على جميع المسارات، ولكن المسارات المعدة مثل تلك التي تم إنشاؤها بواسطة أداة تخطيط المسار، أو أداة الملاحة، أو بعد تصحيح SRTM، لا ينبغي أن يكون للتصفية أي تأثير.

### تصفية ميل 70% {#filter-70-slope}

تعتمد التصفية على إيجاد **النقاط القصوى** التي تكون أعلى أو أقل بكثير من نقطة مجاورة واحدة على اليسار ونقطة مجاورة واحدة على اليمين على الرسم البياني.
تُستبعد هذه **النقاط القصوى** من الحسابات اللاحقة. العتبة ```threshold``` هي [ميل 70%](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationApproximator.java#L11) - [الكود](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationApproximator.java#L72).

**مثال 1**. (جميع النقاط موزعة بمسافة 10 أمتار)، الارتفاع - [5, 3, 10, 3, 5]. 10 هي نقطة قصوى: لأنها 10 > 3 (ميل 70%).

**مثال 2**. (جميع النقاط موزعة بمسافة 10 أمتار)، الارتفاع - [5, 3, 10, 13, 15]. 10 ليست نقطة قصوى: لأن 10 > 3 ولكن 10 < 13، لذا فهي قمة محلية.

### تصفية نقاط القفز {#filter-jumping-points}

تُصفى النقاط التي تمثل تلالًا محلية ```/\```، وهذا يؤدي إلى مشكلة تتمثل في أن أعلى وأدنى نقطة ستُصفى دائمًا، ولكنه يسمح بالتعامل مع المسارات المشوشة حيث لم يكن التسجيل متكررًا، لذا فإن الفحص الأول بالميل الشديد لا يعمل. مرجع إلى [الكود](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationApproximator.java#L49).

**مثال 1**. الارتفاع - [5, 3, 10, 3, 5] -> [5, 5].

**مثال 2**. الارتفاع - [5, 6, 10, 7, 5] -> [5, 6, 7, 5].

**مثال 3**. الارتفاع - [5, 2, 3, 4, 5] -> [5, 3, 4, 5].

### إيجاد النقاط القصوى {#finding-extremums}

لإيجاد النقاط القصوى، تُستخدم خوارزمية [Rames-Dougals-Peucker](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm). ليست هذه الخوارزمية جيدة تمامًا لإيجاد النقاط القصوى بالضبط على الرسم البياني العشوائي، ولكن في حساب الارتفاع، تتجنب الكثير من القمم الصغيرة العشوائية التي يمكن أن تحدث أثناء صعود طويل واحد وبعض الانحدارات القصيرة غير الملحوظة بينهما.

الغرض الرئيسي من الخوارزمية هو إيجاد الحد الأدنى من الخطوط المستقيمة التي يمكن أن تمثل الرسم البياني للارتفاع. العتبة ```threshold``` هي **[7 أمتار](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationDiffsCalculator.java#L13)**. لذا ستُكتشف جميع القمم التي يزيد ارتفاعها عن 7 أمتار على الأسطح المسطحة ولن تُكتشف إذا كانت أقل.

تُعرض النقاط القصوى على الرسم البياني كنقاط زرقاء مع تمكين مكون OsmAnd الإضافي للتطوير.

**مثال 1**. الارتفاع - [0, 0, 10, 0, 0]. **نقطة قصوى** هي 10.

**مثال 2**. الارتفاع - [0, 1, 5, 4, -3, -2, -1, 0]. **لا توجد نقاط قصوى** - جميعها أقل من 7 أمتار فرق.

### حساب الصعود / النزول بين النقاط القصوى {#calculate-uphill--downhill-between-extremums}

على سبيل المثال، إذا كان لديك مسار بسيط يصعد وينزل، فلديك حد أقصى واحد فقط في مسارك، لذا
```
فرق الارتفاع البدائي = <الارتفاع البدائي> - <الارتفاع الأقصى> :
فرق الارتفاع النهائي = <الارتفاع الأقصى> - <الارتفاع النهائي> : إذا كان موجبًا - **صعود**، إذا كان سالبًا - **نزول**
```

1. إذا كان *فرق الارتفاع البدائي* > 0
  - **صعود** = *فرق الارتفاع البدائي*
  - **نزول** = *فرق الارتفاع النهائي*

2. إذا كان *فرق الارتفاع النهائي* > 0
  - **صعود** = *فرق الارتفاع النهائي*
  - **نزول** = *فرق الارتفاع البدائي*

ستُضاف المزيد من الأمثلة.

## تصحيح ارتفاع SRTM {#altitude-srtm-correction}

هناك بديلان يمكن استخدامهما في OsmAnd للحصول على تصحيح الارتفاع.

1. افتح المسار في OsmAnd Android وابحث عن، *تعديل المسار ← خيارات ← تصحيح الارتفاع*
1.1 **عبر الإنترنت** سيعالج المسار عبر خادم OsmAnd والبيانات.
1.2 **غير متصل** سيعالج المسار على الجهاز إذا تم تنزيل ملفات geotifs ثلاثية الأبعاد.
2. افتح الموقع https://osmand.net/map وقم بتحميل المسار واطلع على ارتفاع SRTM.

## الميل {#slope}

يُحسب الرسم البياني الأخضر بطريقة مختلفة عن الصعود / النزول وقد يكون له اختلافات طفيفة. من الناحية النظرية، في جميع **النقاط القصوى**، يجب أن **يتقاطع الرسم البياني الأخضر مع خط الصفر**، على الرغم من أن جميع نقاط الميل الصفري هي نقاط قصوى.

لحساب الميل، تُقسم البيانات بأكملها إلى خطوات متساوية بطول 20 مترًا. لكل نقطة من هذه الشبكة، يُحسب متوسط الارتفاع حول النقطة (نصف قطر 10 أمتار). ثم تُحسب المشتقة المنفصلة باستخدام [الفرق المركزي المحدود](https://en.wikipedia.org/wiki/Finite_difference).