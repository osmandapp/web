---
source-hash: 6f725a1fadd0a2c5cd2626f8424f87e2e54b060d0b683fd33a90f9426413a826
sidebar_position: 5
---

# حساب الصعود / الهبوط / الميل {#calculation-of-uphill--downhill--slope}

يستخدم OsmAnd خوارزميات مختلفة لحساب **الميل** و **الصعود** بناءً على بيانات الأقمار الصناعية SRTM المضمنة في الخرائط غير المتصلة بالإنترنت وبناءً على مسارات GPX المسجلة.

الهدف الرئيسي من حساب **الصعود** هو توفير معلومات ذات صلة حول مقدار **الطاقة الإضافية** التي يتم إنفاقها عند الصعود، ومن الواضح أن ذلك يعتمد على عوامل متعددة مثل نوع المركبة أو طريقة النقل، السطح، وزن الشخص وغيرها.
لذلك في النهاية، يجب أن يكون **الصعود** معلمة تؤخذ في الاعتبار عند التوجيه القائم على الارتفاع، لإنتاج توجيه موفر للطاقة.

الهدف الرئيسي من حساب **الميل** هو الحصول على مؤشر مرئي للطرق شديدة الانحدار التي يجب تجنبها.

## الصعود / الهبوط {#uphill--downhill}

هناك العديد من المشكلات في حساب **الصعود** لأنه لا يوجد معيار، ولأنه يعتمد على طريقة النقل والعديد من المعلمات الأخرى، فمن الصعب توفير تحكم معقول للمستخدم بحيث لا يكون معقدًا للغاية. عادة ما يتم مقارنة الصعود ببرامج أخرى ولكن لا يوجد برنامج لديه معيار ذهبي.

يستخدم OsmAnd خوارزمية من 3 خطوات:

- تصفية البيانات المشوشة.
- إيجاد النقاط القصوى المحلية (الحد الأدنى والحد الأقصى).
- حساب مجموع الفروق بين الحد الأدنى والحد الأقصى.

تحتوي بعض المسارات على الكثير من البيانات المشوشة التي تحتاج إلى تصفية أولاً. في الوقت الحالي، نطبق التصفية على جميع المسارات ولكن المسارات المعدة مثل تلك التي تم إنشاؤها بواسطة أداة تخطيط المسار، أو أداة الملاحة، أو بعد تصحيح SRTM، يجب ألا يكون للتصفية أي تأثير.

### تصفية الميل 70% {#filter-70-slope}

تعتمد التصفية على إيجاد **النقاط المتطرفة** التي تكون أعلى أو أقل بشكل ملحوظ من نقطة مجاورة واحدة على اليسار ونقطة مجاورة واحدة على اليمين على الرسم البياني.
يتم استبعاد هذه **النقاط المتطرفة** من الحسابات اللاحقة. [العتبة] هي [ميل 70%](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationApproximator.java#L11) - [الكود](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationApproximator.java#L72).

**مثال 1**. (جميع النقاط موزعة بمسافة 10 أمتار)، الارتفاع - [5، 3، 10، 3، 5]. 10 هي نقطة متطرفة: لأنها 10 > 3 (ميل 70%).

**مثال 2**. (جميع النقاط موزعة بمسافة 10 أمتار)، الارتفاع - [5، 3، 10، 13، 15]. 10 ليست نقطة متطرفة: لأن 10 > 3 ولكن 10 < 13، لذا فهي قمة محلية.

### تصفية النقاط المتذبذبة {#filter-jumping-points}

يتم تصفية النقاط التي تمثل تلالًا محلية ```/\```، وهذا يؤدي إلى مشكلة أن أعلى وأدنى نقطة سيتم تصفيتها دائمًا، ولكنه يسمح بالتعامل مع المسارات المشوشة حيث لم يكن التسجيل متكررًا، لذا فإن الفحص الأول بالميل الشديد لا يعمل. مرجع إلى [الكود](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationApproximator.java#L49).

**مثال 1**. الارتفاع - [5، 3، 10، 3، 5] -> [5، 5].

**مثال 2**. الارتفاع - [5، 6، 10، 7، 5] -> [5، 6، 7، 5].

**مثال 3**. الارتفاع - [5، 2، 3، 4، 5] -> [5، 3، 4، 5].

### إيجاد النقاط القصوى {#finding-extremums}

لإيجاد النقاط القصوى، يتم استخدام خوارزمية [رامر-دوغلاس-بيوكر](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm). ليست جيدة تمامًا لإيجاد النقاط القصوى بالضبط على الرسم البياني العشوائي، ولكن في حساب الارتفاع تتجنب الكثير من القمم الصغيرة العشوائية التي يمكن أن تحدث خلال صعود طويل واحد وبعض الهبوطات القصيرة غير الملحوظة بينهما.

الغرض الرئيسي من الخوارزمية هو إيجاد الحد الأدنى من الخطوط المستقيمة التي يمكن أن تمثل الرسم البياني للارتفاع. [العتبة] هي **[7 أمتار](https://github.com/osmandapp/OsmAnd/blob/master/OsmAnd-java/src/main/java/net/osmand/gpx/ElevationDiffsCalculator.java#L13)**. لذلك سيتم اكتشاف جميع القمم التي يزيد ارتفاعها عن 7 أمتار على الأسطح المستوية ولن يتم اكتشافها إذا كانت أقل.

تُعرض النقاط القصوى على الرسم البياني كنقاط زرقاء مع تمكين مكون OsmAnd الإضافي للتطوير.

**مثال 1**. الارتفاع - [0، 0، 10، 0، 0]. **النقطة القصوى** هي 10.

**مثال 2**. الارتفاع - [0، 1، 5، 4، -3، -2، -1، 0]. **لا توجد نقاط قصوى** - جميعها أقل من 7 أمتار فرق.

### حساب الصعود / الهبوط بين النقاط القصوى {#calculate-uphill--downhill-between-extremums}

على سبيل المثال، إذا كان لديك مسار بسيط يصعد ويهبط، فلديك حد أقصى واحد فقط في مسارك، لذا فإن
  ```
  فرق ارتفاع البداية = <ارتفاع البداية> - <ارتفاع النقطة القصوى>    :
  فرق ارتفاع النهاية = <ارتفاع النقطة القصوى> - <ارتفاع النهاية>      : إذا كان موجبًا - **صعود**، إذا كان سالبًا - **هبوط**
  ```

1. إذا كان *فرق ارتفاع البداية* > 0
  - **صعود** = *فرق ارتفاع البداية*
  - **هبوط** = *فرق ارتفاع النهاية*

2. إذا كان *فرق ارتفاع النهاية* > 0
  - **صعود** = *فرق ارتفاع النهاية*
  - **هبوط** = *فرق ارتفاع البداية*

سيتم إضافة المزيد من الأمثلة.

## تصحيح ارتفاع SRTM {#altitude-srtm-correction}

هناك بديلان يمكن استخدامهما في OsmAnd للحصول على تصحيح الارتفاع.

1. افتح المسار في OsmAnd Android وابحث عن، *تحرير المسار ← خيارات ← تصحيح الارتفاع*
1.1 **عبر الإنترنت** سيعالج المسار عبر خادم OsmAnd والبيانات.
1.2 **غير متصل** سيعالج المسار على الجهاز إذا تم تنزيل ملفات geotif ثلاثية الأبعاد.
2. افتح موقع الويب https://osmand.net/map وقم بتحميل المسار وشاهد ارتفاع SRTM.

## الميل {#slope}

يتم حساب الرسم البياني الأخضر بشكل مختلف عن الصعود / الهبوط وقد يكون له اختلافات طفيفة. من الناحية النظرية، في جميع **النقاط القصوى** يجب أن **يتقاطع** الرسم البياني الأخضر مع **خط الصفر**، على الرغم من أن جميع نقاط الميل الصفري هي نقاط قصوى.

لحساب الميل، يتم تقسيم البيانات بالكامل إلى خطوات متساوية بطول 20 مترًا. لكل نقطة من هذه الشبكة، يتم حساب متوسط الارتفاع حول النقطة (نصف قطر 10 أمتار). ثم يتم حساب المشتقة المنفصلة باستخدام [الفرق المركزي المحدود](https://en.wikipedia.org/wiki/Finite_difference).
